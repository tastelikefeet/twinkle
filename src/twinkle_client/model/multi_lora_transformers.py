# ============================================================================
# WARNING: AUTO-GENERATED FILE - DO NOT MODIFY MANUALLY!
# ============================================================================
# This file is automatically generated by client_tools/client_generator.py
# Any manual changes will be overwritten when the generator runs again.
#
# To update this file:
#   1. Modify the source files in src/twinkle/
#   2. Run: python client_tools/client_generator.py
# ============================================================================
from typing import Any, Optional, Union, Type, Dict, Literal, List
import uuid
from twinkle_client.http import http_post, heartbeat_manager
from twinkle import DeviceMesh
from twinkle.data_format import InputFeature, Trajectory


class MultiLoraTransformersModel:
    """Client wrapper for TwinkleModel that calls server HTTP endpoints.

    This client manages adapters and sends training/inference requests to the model server.
    Each adapter has its own lifecycle managed through automatic heartbeats.
    """

    def __init__(self, model_id: str, **kwargs):
        """Initialize model client."""
        from twinkle_client.http import get_base_url
        self.server_url = get_base_url()

        self.model_id = model_id
        if '://' in model_id:
            model_id = model_id.split('://')[1]
        self.server_url = f'{self.server_url}/models/{model_id}'
        self.adapter_name = None
        response = http_post(
            url=f'{self.server_url}/create',
        )
        response.raise_for_status()

    def _send_adapter_heartbeat(self):
        """Internal method to send adapter heartbeat."""
        response = http_post(
            url=f'{self.server_url}/heartbeat',
            json_data={'adapter_name': self.adapter_name}
        )
        response.raise_for_status()

    def add_adapter_to_model(self, adapter_name: str, config: Dict[str, Any], **kwargs):
        """Add a new adapter to the model and start automatic heartbeat."""
        response = http_post(
            url=f'{self.server_url}/add_adapter_to_model',
            json_data={'adapter_name': adapter_name, 'config': config, **kwargs}
        )
        response.raise_for_status()

        # Register adapter for automatic heartbeat after successful creation
        self.adapter_name = adapter_name
        heartbeat_manager.register_adapter(
            self.adapter_name,
            self._send_adapter_heartbeat
        )

    def __del__(self):
        """Cleanup: unregister adapter from heartbeat manager."""
        try:
            heartbeat_manager.unregister_adapter(self.adapter_name)
        except:
            pass

    def forward(self, inputs: Any, **kwargs):
        """Execute forward pass on the model."""
        response = http_post(
            url=f'{self.server_url}/forward',
            json_data={'inputs': inputs, 'adapter_name': self.adapter_name, **kwargs}
        )
        response.raise_for_status()
        return response.json()['result']

    def forward_only(self, inputs: Any, **kwargs):
        """Execute forward pass without gradient computation."""
        response = http_post(
            url=f'{self.server_url}/forward_only',
            json_data={'inputs': inputs, 'adapter_name': self.adapter_name, **kwargs}
        )
        response.raise_for_status()
        return response.json()['result']

    def calculate_loss(self, **kwargs):
        """Calculate loss from model outputs."""
        response = http_post(
            url=f'{self.server_url}/calculate_loss',
            json_data={'adapter_name': self.adapter_name, **kwargs}
        )
        response.raise_for_status()
        return response.json()['result']

    def get_train_configs(self, **kwargs):
        """Get training configs"""
        response = http_post(
            url=f'{self.server_url}/get_train_configs',
            json_data={'adapter_name': self.adapter_name, **kwargs}
        )
        response.raise_for_status()
        return response.json()['result']

    def backward(self, **kwargs):
        """Execute backward pass."""
        response = http_post(
            url=f'{self.server_url}/backward',
            json_data={'adapter_name': self.adapter_name, **kwargs}
        )
        response.raise_for_status()
        return response.json()['result']

    def forward_backward(self, inputs: Any, **kwargs):
        """Execute combined forward and backward pass."""
        response = http_post(
            url=f'{self.server_url}/forward_backward',
            json_data={'inputs': inputs, 'adapter_name': self.adapter_name, **kwargs}
        )
        response.raise_for_status()
        return response.json()['result']

    def step(self, **kwargs):
        """Execute optimizer step."""
        response = http_post(
            url=f'{self.server_url}/step',
            json_data={'adapter_name': self.adapter_name, **kwargs}
        )
        response.raise_for_status()
        return response.json()['result']

    def zero_grad(self, **kwargs):
        """Zero out gradients."""
        response = http_post(
            url=f'{self.server_url}/zero_grad',
            json_data={'adapter_name': self.adapter_name, **kwargs}
        )
        response.raise_for_status()
        return response.json()['result']

    def lr_step(self, **kwargs):
        """Execute learning rate scheduler step."""
        response = http_post(
            url=f'{self.server_url}/lr_step',
            json_data={'adapter_name': self.adapter_name, **kwargs}
        )
        response.raise_for_status()
        return response.json()['result']

    def set_loss(self, loss_cls: str, **kwargs):
        """Set the loss function."""
        response = http_post(
            url=f'{self.server_url}/set_loss',
            json_data={'loss_cls': loss_cls, 'adapter_name': self.adapter_name, **kwargs}
        )
        response.raise_for_status()
        return response.json()['result']

    def clip_grad_norm(self, max_grad_norm: float=1.0, norm_type=2, **kwargs):
        """Set the loss function."""
        response = http_post(
            url=f'{self.server_url}/clip_grad_norm',
            json_data={'max_grad_norm': max_grad_norm, 'norm_type': norm_type, 'adapter_name': self.adapter_name, **kwargs}
        )
        response.raise_for_status()
        return response.json()['result']

    def set_optimizer(self, optimizer_cls: str, **kwargs):
        """Set the optimizer."""
        response = http_post(
            url=f'{self.server_url}/set_optimizer',
            json_data={'optimizer_cls': optimizer_cls, 'adapter_name': self.adapter_name, **kwargs}
        )
        response.raise_for_status()
        return response.json()['result']

    def set_lr_scheduler(self, scheduler_cls: str, **kwargs):
        """Set the learning rate scheduler."""
        response = http_post(
            url=f'{self.server_url}/set_lr_scheduler',
            json_data={'scheduler_cls': scheduler_cls, 'adapter_name': self.adapter_name, **kwargs}
        )
        response.raise_for_status()
        return response.json()['result']

    def save(self, name: str, **kwargs):
        """Save model checkpoint."""
        response = http_post(
            url=f'{self.server_url}/save',
            json_data={'name': name, 'adapter_name': self.adapter_name, **kwargs}
        )
        response.raise_for_status()
        return response.json()['result']

    def load(self, name: str, **kwargs):
        """Load model checkpoint."""
        response = http_post(
            url=f'{self.server_url}/load',
            json_data={'name': name, 'adapter_name': self.adapter_name, **kwargs}
        )
        response.raise_for_status()
        return response.json()['result']

    def set_template(self, template_cls: str, **kwargs):
        """Set the template for data processing."""
        response = http_post(
            url=f'{self.server_url}/set_template',
            json_data={'template_cls': template_cls, 'adapter_name': self.adapter_name, 'model_id': self.model_id, **kwargs}
        )
        response.raise_for_status()
        return response.json()['result']

    def set_processor(self, processor_cls: str, **kwargs):
        """Set the input processor."""
        response = http_post(
            url=f'{self.server_url}/set_processor',
            json_data={'processor_cls': processor_cls, 'adapter_name': self.adapter_name, **kwargs}
        )
        response.raise_for_status()
        return response.json()['result']

    def calculate_metric(self, is_training: bool = True, **kwargs):
        """Calculate metrics from model outputs."""
        response = http_post(
            url=f'{self.server_url}/calculate_metric',
            json_data={'is_training': is_training, 'adapter_name': self.adapter_name, **kwargs}
        )
        response.raise_for_status()
        return response.json()['result']

    def get_state_dict(self, **kwargs):
        """Get model state dictionary."""
        response = http_post(
            url=f'{self.server_url}/get_state_dict',
            json_data={'adapter_name': self.adapter_name, **kwargs}
        )
        response.raise_for_status()
        return response.json()['result']

    def upload_to_hub(self, checkpoint_dir: str, hub_model_id: str, hub_token: Optional[str] = None, async_upload: bool = True):
        """Upload model checkpoint to hub.

        Args:
            checkpoint_dir: The directory path of the checkpoint to upload.
            hub_model_id: The hub model id.
            hub_token: The hub token (optional).
            async_upload: Whether to use async upload (default: True).
        """
        response = http_post(
            url=f'{self.server_url}/upload_to_hub',
            json_data={
                'checkpoint_dir': checkpoint_dir,
                'hub_model_id': hub_model_id,
                'hub_token': hub_token,
                'async_upload': async_upload
            }
        )
        response.raise_for_status()
        return response.json()
